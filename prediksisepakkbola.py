# -*- coding: utf-8 -*-
"""PrediksiSepakkbola.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BH4KuWJ7Y2zaWaWr13w7cuZXLDGeoY0x

# **Prediksi Pertandingan Liga Inggris**

Dataset_2023.2024.xlsx merupkan sebuah dataset dari pertandingan liga Inggris tahun 2023/2024. dataset ini berisi 28 columns dan 760 rows. Dataset ini bisa digunakan untuk model klasifikasi dengan label result pertandingan apakah itu win lost ataupun draw.

LINK DATASET: [Premier League Match Result](https://www.kaggle.com/datasets/pourea/premier-league-match-results)

## **Import Library yang dibutuhkan**
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

"""## **Load Dataset**"""

df=pd.read_excel('Dataset_2023.2024.xlsx')
df

"""| Kolom       | Tipe Data | Deskripsi                                           |
|-------------|-----------|-----------------------------------------------------|
| Team        | String    | Nama tim sepak bola                                 |
| Status      | String    | Status tim (Home atau Guest)                        |
| Team rating | Float     | Rating keseluruhan tim                              |
| CB          | Integer   | Jumlah pemain Center Back                           |
| LB          | Integer   | Jumlah pemain Left Back                             |
| RB          | Integer   | Jumlah pemain Right Back                            |
| ST          | Integer   | Jumlah pemain Striker                               |
| CM          | Integer   | Jumlah pemain Center Midfielder                     |
| AM          | Integer   | Jumlah pemain Attacking Midfielder                  |
| LM          | Integer   | Jumlah pemain Left Midfielder                       |
| DM          | Integer   | Jumlah pemain Defensive Midfielder                  |
| RM          | Integer   | Jumlah pemain Right Midfielder                      |
| LW          | Integer   | Jumlah pemain Left Winger                           |
| RW          | Integer   | Jumlah pemain Right Winger                          |
|Rival Team Rating| Integer | Rating Keseluruhan Tim Lawan
| CBr         | Integer   | Jumlah pemain CB dari formasi lawan                 |
| LBr         | Integer   | Jumlah pemain LB dari formasi lawan                 |
| RBr         | Integer   | Jumlah pemain RB dari formasi lawan                 |
| STr         | Integer   | Jumlah pemain ST dari formasi lawan                 |
| CMr         | Integer   | Jumlah pemain CM dari formasi lawan                 |
| AMr         | Integer   | Jumlah pemain AM dari formasi lawan                 |
| LMr         | Integer   | Jumlah pemain LM dari formasi lawan                 |
| DMr         | Integer   | Jumlah pemain DM dari formasi lawan                 |
| LWr         | Integer   | Jumlah pemain LW dari formasi lawan                 |
| RWr         | Integer   | Jumlah pemain RW dari formasi lawan                 |
| RMr         | Integer   | Jumlah pemain RM dari formasi lawan                 |
| Result      | String    | Hasil pertandingan (Win, Lost, Draw)                |
| Round       | Integer   | Putaran atau minggu ke berapa pertandingan berlangsung |

## **Exploratory Data Analysis (EDA)**
"""

# Mengecek apakah ada data yang kosong
df.isnull().sum()

"""**Hasil** : Berdasarkan hasil pengecekan tidak terdapat data yang kosong atau nan,maka dari itu kita bisa teruskan ke data preparation lainnya"""

# Mengecek tipe data dan info perkolom
df.info()

"""**Hasil** :Berdasarkan info kolom terdapat 28 kolom dan memiliki type data 23 berbentuk intejer 2 float dan 3 object."""

# Melihat jumlah baris dan kolom
df.shape

"""**Hasil** :Penguatan dari sebelumnya terdapat 760 baris dan 28 kolom"""

# Melihat apakah ada outlier
df.describe()

"""**Hasil** Tidak terdapat outlier dan semua data dipastikan aman"""

# Cek apakah ada data duplikat
df.duplicated().sum()

"""**Hasil** Tidak terdapat duplikat"""

# Encoding kolom 'Team'
le_team = LabelEncoder()
df['Team_encoded'] = le_team.fit_transform(df['Team'])
# Encoding kolom 'Team'
le_status = LabelEncoder()
df['Status_encoded'] = le_status.fit_transform(df['Status'])

"""**Hasil** :Melakukan Pengubahan data berbentuk object ke angka"""

# Lihat tabel apakah sudah ada kolom hasil encoded
df

"""**Hasil** : Terdapat Kolom baru bernama team_encoded dan status_encoded dimana hasil encoding pada kolom team dan status yang awalnya berbentuk object menjadi angka."""

# Cek Rejumlah Result karena ingin dijadikan label
df['Result'].value_counts()

"""**Hasil** : Terdapat 3 kelas yang dipakai yaitu win lost dan draw"""

# Visualisasi untuk melihat kemenangan berdasarkan rating team
plt.figure(figsize=(8, 4))
sns.histplot(data=df, x='Team rating', hue='Result', bins=30, kde=True, palette='Set1')
plt.title("Distribusi Kemenangan Berdasarkan Rating Team")
plt.xlabel("Rating Tim")
plt.ylabel("Jumlah")
plt.tight_layout()
plt.show()

"""**Hasil** : Visualisasi distribusi kemenangan berdasarkan rating. Ditemukan rating tim memiliki pengaruh signifikan terhadap hasil pertandingan."""

# Viusalisasi Hasil Pertandingan Berdasarkan Status (Home/Away)
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 4))
sns.countplot(data=df, x='Status', hue='Result', palette='Set2')
plt.title("Distribusi Hasil Pertandingan Berdasarkan Status (Home/Away)")
plt.xlabel("Status")
plt.ylabel("Jumlah")
plt.tight_layout()
plt.show()

"""**Hasil** : Visualisasi distribusi berdasarkan status bertanding. Mendapatkan hasil Tim yang bermain sebagai tuan rumah (Home) memiliki kemungkinan menang lebih tinggi dibandingkan tim tamu (Guest).

## **Mengambil Fitur dan Membagi Menjadi Data Latih dan Data Uji**
"""

# Ambil variabel fitur selain result,karena untuk label,sedangkan team dan status untuk karena sudah di encoding menjadi team dan status encoded
X = df.drop(columns=['Result','Team','Status'], axis=1)
y = df['Result']

"""**Hasil**: x= mengambil semua kolom kecuali team,status dan result. y=kolom label yang akan digunakan"""

# Membagi dataset dengan 80% data latih dan 20% data uji
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, random_state=2)

"""**Hasil**: Setelah di split data dibagi menjadi 80% data latih dan 20% data uji"""

# Melihat hasil splitting
print(X.shape, X_train.shape, X_test.shape)

"""**Hasil**:(608 baris,27 kolom) merupakan data latih yang dipakai,dan (152 baris, 27 kolom) sebagai data uji.

## **Membuat Model Machine Learning**

### Menggunakan Algoritma RandomForest

Random Forest dalah algoritma ensemble yang membangun banyak pohon keputusan (decision tree) dan menggabungkan  hasilnya untuk meningkatkan akurasi dan mencegah overfitting. Cara Kerja:

    - Bootstrap Sampling: Dataset dilatih secara acak (sampling dengan pengembalian) untuk membuat beberapa subset data (bootstrap samples).
    - Pembangunan Pohon: Untuk setiap subset, dibangun satu pohon keputusan menggunakan sebagian fitur secara acak.
    - Voting (Klasifikasi) atau Rata-rata (Regresi):
    - Untuk klasifikasi: Setiap pohon memberikan suara (vote), dan kelas dengan suara terbanyak adalah hasil akhir.
    - Untuk regresi: Mengambil rata-rata dari hasil semua pohon.
"""

# Model yang Dibuat Pertama adalah RandomForest
model = RandomForestClassifier(
   n_estimators=100,         # Jumlah pohon dalam hutan (semakin banyak → hasil lebih stabil)
    max_depth=None,           # Tidak ada batasan kedalaman pohon (berpotensi overfitting)
    min_samples_split=2,      # Minimum sampel untuk membagi node (default: 2)
    min_samples_leaf=1,       # Minimum sampel di setiap daun pohon (default: 1 → pohon sangat fleksibel)
    random_state=42           # Seed untuk hasil yang konsisten setiap kali dijalankan
)

model.fit(X_train,y_train)

"""**Hasil**: Model Random Forest Berhasil di Buat"""

# Prediksi Dengan Algoritma Random Forest
y_pred_RF = model.predict(X_test)
y_pred_RF

"""**Hasil**: Hasil dari Prediksi model random forest"""

# Evaluasi Random Forest
print("Akurasi Testing:", accuracy_score(y_test, y_pred_RF))
print("\nClassification Report:\n", classification_report(y_test, y_pred_RF))

"""**Hasil**: Hasil Akurasi Random Forest sebanyak 0.84 atau 84%"""

# Membuat confusion matrix
cm = confusion_matrix(y_test, y_pred_RF)
labels = sorted(y_test.unique())  # untuk label sumbu jika y_test adalah DataFrame/Series dengan kategori

# Visualisasi confusion matrix
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.tight_layout()
plt.show()

"""**Hasil**: Merupakan tampilan confution matrix dimana draw actual di prediksi sebanyak 13 kali,lost aktual 56 kali,dan win actual 59 kali.

### Menggunakan Naive Bayes

Naive Bayes adalah algoritma klasifikasi berdasarkan Teorema Bayes dengan asumsi kuat (naive) bahwa fitur-fitur bersifat independen satu sama lain. Cara Kerja :

    - Menghitung Probabilitas Kelas: Misalnya menghitung P(Positif) dan P(Negatif) dari data latih.
    - Menghitung Probabilitas Kondisional: Misalnya P(Fitur | Kelas) untuk setiap fitur.
    - Menerapkan Teorema Bayes.
    - Prediksi: Memilih kelas dengan nilai probabilitas terbesar.
"""

# Selanjutnya Dengan Algoritma Naive Bayes
model_NB = GaussianNB()
model_NB.fit(X_train, y_train)

"""**Hasil**: Berhasil membuat model naive bayes"""

# Prediksi Model Naive Bayes
y_pred_NB = model_NB.predict(X_test)
y_pred_NB

"""**Hasil**: Hasil dari prediksi menggunakan model naive bayes"""

# Evaluasi Naive Bayes
print("Akurasi Testing:", accuracy_score(y_test, y_pred_NB))
print("\nClassification Report:\n", classification_report(y_test, y_pred_NB))

"""**Hasil**: Hasil akurasinya adalah 0.79"""

# Membuat confusion matrix NB
cm = confusion_matrix(y_test, y_pred_NB)
labels = sorted(y_test.unique())  # untuk label sumbu jika y_test adalah DataFrame/Series dengan kategori

# Visualisasi confusion matrix NB
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.tight_layout()
plt.show()

"""**Hasil**: Berdasarkan model naive bayes draw actual 11 prediksi benar,lost aktual 54 prediksi benar, dan win actual 56 prediksi benar.

### Model SVM

SVM(Support Vector Machine) adalah algoritma klasifikasi yang mencari garis pemisah (hyperplane) terbaik yang memisahkan kelas data dengan margin terbesar. Cara Kerja:

    - SVM mencari hyperplane (garis di 2D, bidang di 3D, dst.) yang memaksimalkan margin antara dua kelas.
    - Support Vectors: Titik data paling dekat dengan hyperplane yang menentukan posisinya.
    - Untuk data yang tidak linear, SVM menggunakan kernel trick (misalnya RBF, polynomial) untuk memetakan data ke dimensi lebih tinggi agar bisa dipisahkan secara linear.
"""

# Membuat Model SVM
svm_model = SVC(
   kernel='rbf',         # Jenis kernel yang digunakan; 'rbf' cocok untuk data non-linear
    C=1.0,                # Parameter regularisasi; semakin tinggi → penalti kesalahan makin besar
    gamma='scale',        # Koefisien kernel; 'scale' menghitung otomatis berdasarkan fitur
    probability=True,     # Mengaktifkan prediksi probabilitas (dibutuhkan untuk evaluasi seperti ROC AUC)
    random_state=42       # Seed untuk hasil yang konsisten pada percobaan berulang
)

svm_model.fit(X_train,y_train)

"""**Hasil**: Berhasil membuat model svm"""

# Lakukan Prediksi SVM
y_pred_svm = svm_model.predict(X_test)
y_pred_svm

"""**Hasil**: Hasil prediksi dengan model SVM"""

# Evaluasi SVM
print("Akurasi Testing:", accuracy_score(y_test, y_pred_svm))
print("\nClassification Report:\n", classification_report(y_test, y_pred_svm))

"""**Hasil**: Model svm memiliki akurasi testing 0.70,tetapi tidak dapat memprediksi hasil draw.

"""

# Membuat confusion matrix SVM
cm = confusion_matrix(y_test, y_pred_svm)
labels = sorted(y_test.unique())  # untuk label sumbu jika y_test adalah DataFrame/Series dengan kategori

# Visualisasi confusion matrix SVM
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.tight_layout()
plt.show()

"""**Hasil**: Model SVM tidak dapat memprediksi hasil draw,kemudian 53 prediksi benar lost,dan 54 prediksi benar tim yang win

##  **Analsis Hasil Evaluasi Model Klasifikasi**

 Berdasarkan hasil evaluasi dengan menggunakan ke-3 model klasifikasi dapat disimpulkan :

 1. Algoritma Random Forest lebih baik dengan hasil prediksi diangka 84%,sedangkan Naive Bayes 80%, dan SVM 70%.

 2. Alasan Algortima Random Forest lebih baik karena :

    - Tahan terhadap overfitting.
    - Bisa menangani banyak fitur tanpa perlu feature selection.
    - Memberikan feature importance.

3. Meskipun hasil Random Forest lebih bagus, algoritma ini belum maksimal untuk melihat hasil draw, karena hasil dari matriks evaluasi melihatkan hasil 57%. Tetapi hal tersebut juga bisa dikarenakan nilai draw lebih sedikit dibangdingkan win dan lost.
"""